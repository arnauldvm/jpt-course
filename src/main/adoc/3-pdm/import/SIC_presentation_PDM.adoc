Performance Diagnostic Model and sample case studies
====================================================
:author:        Arnauld Van Muysewinkel
:email:         Arnauld.VanMuysewinkel@smals.be
:copyright:     SIC @Smals
:revision:      0.0.1
:revdate:       24-Sep-2014
:revremark:     DRAFT
:service:       SIC
:backend:       slidy
:duration:      30
:theme:         volnitsky
:max-width:     45em
:icons:
:data-uri:
:pdm-width:			25%

Plan
----
* Objective
* References
* The four layers model
* Dominator Decision Tree
* Using vmstat
* Case studies

Objective
---------


References
----------

Performance tuning::
* *Java Performance Tuning (training/workshop). Kirk Perdine. Kodewerk*
   http://www.kodewerk.com/workshop.html
* Java Performance. Charlie Hunt, Binu John. 2011. The Java Series. Addison-Wesley Professional
* Java Performance (The Definitie Guide). Scott Oaks. 2014. O'Reilly Media

Broader scope::
* Effective Java (2nd Edition). Joshua Bloch. 2008. The Java Series. Addison-Wesley
* Java Concurrency in Practice. Brian Goetz et al. 2006. Addison-Wesley Professional


Performance Diagnostic Model (PDM)
----------------------------------

* abstract model of a (Java) "system"
* identify important sub-systems and their role in the whole
* *4 layers model*
* each sub-system provides specific resource(s) +
  => is responsible for specific performance issues
* define measurements applicable to each sub-system
* define a methodology to study the system


Layer 1: OS
-----------

[width="{pdm-width}", halign="center", float="right"]
|===========
| {nbsp}
| {nbsp}
| {nbsp}
| OS (Hardware)
|===========

Role:: Manages access to hardware via:
* device drivers -> uses interrupts
* queues -> uses memory
* schedulers -> uses CPU

Resources::
* CPU: threads schedulling, locks
* Memory managemebt
* I/O: disk, net

*Hardware resources have limited capacity!*


Layer 2: JVM
------------

[width="{pdm-width}", halign="center", float="right"]
|===========
| {nbsp}
| {nbsp}
| Java VM
| OS (Hardware)
|===========

Role::
* byte code interpretation
* Just-In-Time (JIT) compilation
* Memory management:
** Memory allocation
** Garbage Collector (GC)

Resources::
* Memory
* Process


Layer 3: Application
--------------------

[width="{pdm-width}", halign="center", float="right"]
|===========
| {nbsp}
| Application
| Java VM
| OS (Hardware)
|===========

Role::
* interpret end-user demands
* arbitrate access to non-sharable resources (locks)
* interacts with external systems

Resources::
* locks
* external systems


Layer 4: Actors
---------------

[width="{pdm-width}", halign="center", float="right"]
|===========
| Actors
| Application
| Java VM
| OS (Hardware)
|===========

Role::
* places load on the system: end-user, external systems, batches

Usage patterns?::
* use cases
* load (# of concurrent users)
* velocity (speed of execution)
* ...


4 Layers: Summary
-----------------

[width="50%", halign="center", align="center"]
|===========
| *Actors* +
Usage patterns
| *Application* +
Locks, External systems
| *Java VM* +
Memory, Process
| *OS (Hardware)* +
CPU, Memory, Disk IO, Network, Locks
|===========


Dominant Consumers
------------------

To pose a diagnostic, we'll try to identify the dominant consumer of the CPU.

Four candidates::
[role="incremental"]
* 'Application' -> architecture? algorithmic?
* 'JVM' -> objects life-cycle? JIT? (very rare)
* 'OS' -> inefficient use of resources?
* '"None"' -> something else is keeping threads out of the CPU
** ! Check 'Actors' -> Is there enough load on the system?


Dominant Consumer: OS
---------------------

[width="{pdm-width}", halign="center", float="right"]
|===========
| Actors
| Application
| Java VM
| *OS (Hardware)*
|===========

Usual causes::
* excessive context switching
** lock contention?
* Disk I/O
* Network I/O

If OS spends time managing access to resources, there will be more CPU system time than usual.

IMPORTANT: *Symptom* +
Proportion of CPU system time vs. user time is too high.


Dominant Consumer: JVM
----------------------

[width="{pdm-width}", halign="center", float="right"]
|===========
| Actors
| Application
| *Java VM*
| OS (Hardware)
|===========

Usual causes::
* Memory management
** memory leaks, System.gc(), premature promotion, memory pools sizing
* (JIT tuning usually not necessary, except when extreme speed is needed)

Examine GC log.

IMPORTANT: *Symptom* +
GC CPU ratio too high (too many GC events, too much time in GC...)


Dominant Consumer: Application
------------------------------

[width="{pdm-width}", halign="center", float="right"]
|===========
| Actors
| *Application*
| Java VM
| OS (Hardware)
|===========

Usual causes::
* Wrong algorithm
* Unnecessary work
* ...

Execution profiling.

IMPORTANT: *Symptoms* +
- High CPU and no abnormal pattern in GC log
- Too many threads waiting for CPU


Dominant Consumer: "None"
-------------------------

Usual causes::
* slow I/O
* synchronous calls to slow external systems
* over worked connection or thread pool
* faulty, misconfigured or otherwise slow hardware network/disk
** DNS

_+ Make sure there is enough load on the system!_

IMPORTANT: *Symptom* +
Low CPU usage and no system CPU time


Dominator Decision Tree
-----------------------

image::images/DominatorDecisionTree.png[height="450", align="center"]


Resources consumption monitoring: vmstat
----------------------------------------

[source,sh]
----
> vmstat [delay_in_sec [count]]
----
On Linux +
image:images/vmstat_linux.png[align="left"] +
On Solaris +
image:images/vmstat_solaris.png[align="left"]

CAUTION: First line shows consolidate data since boot time +
Each next line covers one interval of time (delay_in_sec)


Resources consumption monitoring: Perfmon
-----------------------------------------

On Windows +
image:images/perfmon_windows.png[width="700", align="center"]


Case studies: CPU bottleneck
----------------------------

image:images/vmstat_sample_r.png[align="left"]

IMPORTANT: *Symptoms* +
+r >> 2 * # CPU+ (4 in this case)

TIP: *Resolution* +
- add more CPU +
- or optimize algorithm (e.g. https://en.wikipedia.org/wiki/Strength_reduction[strength reduction])


Case studies: starvation
------------------------

image:images/vmstat_sample_cs.png[align="left"]

IMPORTANT: *Symptoms* +
+cs high and CPU low+ -> Lots of context switching +
=> threads don't consume their alloted time quantum

TIP: *Resolution* +
find what's blocking threads progress: locks, I/O, network 


Case studies: Dominant OS
-------------------------

image:images/vmstat_sample_us-sy.png[align="left"]

IMPORTANT: *Symptoms* +
+sy > us รท 10+ -> OS activity dominates

TIP: *Resolution* +
- high cs -> lock contention? +
- I/O? (disk or network)


Memory usage monitoring: GC log
-------------------------------

NOTE: Will be described in a future presentation.

Application behaviour: Profiling
--------------------------------

NOTE: Will be described in a future presentation.
