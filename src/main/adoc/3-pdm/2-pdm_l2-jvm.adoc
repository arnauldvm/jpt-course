// build_options: 
Java Performance Tuning - PDM Layer 2 : Java Virtual Machine
============================================================
Arnauld Van Muysewinkel <avm@pendragon.be>
v0.1, 27-Oct-2015: Draft version
:backend: slidy
//:theme: volnitsky
:data-uri:
:copyright: Creative-Commons-Zero (Arnauld Van Muysewinkel)
:pdm-width: 25%
:tabletags-green.bodydata: <td style="background-color:palegreen;text-align:center">|</td>
:tabledef-default.green-style: tags="green"
:nil: pass:[</>]


Content
-------

* ...
* metrics: GC log, heapdump
* tools: GC Viewer, custom scripts, MAT

_(link:../0-extra/1-training_plan.html#_presentations[back to course plan])_


Dominant Consumer: JVM
----------------------

[width="{pdm-width}", halign="center", float="right"]
|===========
| Actors
| Application
g| Java VM
| OS (Hardware)
|===========

Usual causes::
* Memory management
** memory leaks, System.gc(), premature promotion, memory pools sizing
* (JIT tuning usually not necessary, except when extreme speed is needed)

Examine GC log.

IMPORTANT: *Symptom* +
GC CPU ratio too high (too many GC events, too much time in GC...)


Memory usage monitoring: GC log
-------------------------------

Records all activities of the GC.

-> By analyzing, one can extract the following metrics:

[horizontal]
Liveset:: amount of memory actually required. Given the behaviour of the garbage collection,
it is known only after an old (full) collection. +
-> *memory leak* detection
Memory allocation rate:: speed of memory allocation by the application.
It depends on the application usage and application implementation details. +
-> in general systems are able to sustain a rate <{nil}= *500 MB/s*, not more
GC CPU usage:: proportion of time the CPU is busy doing GC +
-> Should not exceed *2-3%*
CPU throuhgput:: proportion of time the CPU is _not_ busy doing GC +
-> +100% - GC CPU usage+
